//
// Generated by Bluespec Compiler, version 2021.12.1 (build fd501401)
//
// On Thu Jun  1 01:28:34 IST 2023
//
//
// Ports:
// Name                         I/O  size props
// CLK                            I     1 clock
// RST_N                          I     1 reset
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkTb(CLK,
	    RST_N);
  input  CLK;
  input  RST_N;

  // register cntr
  reg [31 : 0] cntr;
  wire [31 : 0] cntr$D_IN;
  wire cntr$EN;

  // register cycle_cntr
  reg [31 : 0] cycle_cntr;
  wire [31 : 0] cycle_cntr$D_IN;
  wire cycle_cntr$EN;

  // register kh
  reg [31 : 0] kh;
  wire [31 : 0] kh$D_IN;
  wire kh$EN;

  // register kl
  reg [31 : 0] kl;
  wire [31 : 0] kl$D_IN;
  wire kl$EN;

  // register m
  reg [31 : 0] m;
  wire [31 : 0] m$D_IN;
  wire m$EN;

  // register n
  reg [31 : 0] n;
  wire [31 : 0] n$D_IN;
  wire n$EN;

  // register x
  reg [31 : 0] x;
  wire [31 : 0] x$D_IN;
  wire x$EN;

  // register y
  reg [31 : 0] y;
  wire [31 : 0] y$D_IN;
  wire y$EN;

  // ports of submodule dut
  wire [31 : 0] dut$check_h,
		dut$check_kkh,
		dut$check_kkl,
		dut$check_l,
		dut$check_m,
		dut$check_n,
		dut$done,
		dut$get_input_size_img_height,
		dut$get_input_size_img_width,
		dut$get_input_size_num_c,
		dut$get_weight_size_kernel_height,
		dut$get_weight_size_kernel_width,
		dut$get_weight_size_m_filters,
		dut$read_check;
  wire [3 : 0] dut$state_check;
  wire dut$EN_get_input_size, dut$EN_get_weight_size;

  // inputs to muxes for submodule ports
  wire [31 : 0] MUX_cntr$write_1__VAL_2;

  // submodule dut
  mkGNA dut(.CLK(CLK),
	    .RST_N(RST_N),
	    .get_input_size_img_height(dut$get_input_size_img_height),
	    .get_input_size_img_width(dut$get_input_size_img_width),
	    .get_input_size_num_c(dut$get_input_size_num_c),
	    .get_weight_size_kernel_height(dut$get_weight_size_kernel_height),
	    .get_weight_size_kernel_width(dut$get_weight_size_kernel_width),
	    .get_weight_size_m_filters(dut$get_weight_size_m_filters),
	    .EN_get_input_size(dut$EN_get_input_size),
	    .EN_get_weight_size(dut$EN_get_weight_size),
	    .RDY_get_input_size(),
	    .RDY_get_weight_size(),
	    .check_kkl(dut$check_kkl),
	    .RDY_check_kkl(),
	    .check_n(dut$check_n),
	    .RDY_check_n(),
	    .check_l(dut$check_l),
	    .RDY_check_l(),
	    .check_kkh(dut$check_kkh),
	    .RDY_check_kkh(),
	    .check_m(dut$check_m),
	    .RDY_check_m(),
	    .check_h(dut$check_h),
	    .RDY_check_h(),
	    .done(dut$done),
	    .RDY_done(),
	    .state_check(dut$state_check),
	    .RDY_state_check(),
	    .read_check(dut$read_check),
	    .RDY_read_check());

  // inputs to muxes for submodule ports
  assign MUX_cntr$write_1__VAL_2 = cntr + 32'd1 ;

  // register cntr
  assign cntr$D_IN = (cntr == 32'd1) ? dut$done : MUX_cntr$write_1__VAL_2 ;
  assign cntr$EN = cntr == 32'd1 || cntr == 32'd0 ;

  // register cycle_cntr
  assign cycle_cntr$D_IN = cycle_cntr + 32'd1 ;
  assign cycle_cntr$EN = cntr == 32'd1 ;

  // register kh
  assign kh$D_IN = 32'h0 ;
  assign kh$EN = 1'b0 ;

  // register kl
  assign kl$D_IN = 32'h0 ;
  assign kl$EN = 1'b0 ;

  // register m
  assign m$D_IN = 32'h0 ;
  assign m$EN = 1'b0 ;

  // register n
  assign n$D_IN = 32'h0 ;
  assign n$EN = 1'b0 ;

  // register x
  assign x$D_IN = 32'h0 ;
  assign x$EN = 1'b0 ;

  // register y
  assign y$D_IN = 32'h0 ;
  assign y$EN = 1'b0 ;

  // submodule dut
  assign dut$get_input_size_img_height = x ;
  assign dut$get_input_size_img_width = y ;
  assign dut$get_input_size_num_c = n ;
  assign dut$get_weight_size_kernel_height = kh ;
  assign dut$get_weight_size_kernel_width = kl ;
  assign dut$get_weight_size_m_filters = m ;
  assign dut$EN_get_input_size = cntr == 32'd0 ;
  assign dut$EN_get_weight_size = cntr == 32'd0 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        cntr <= `BSV_ASSIGNMENT_DELAY 32'd0;
	cycle_cntr <= `BSV_ASSIGNMENT_DELAY 32'd0;
	kh <= `BSV_ASSIGNMENT_DELAY 32'd3;
	kl <= `BSV_ASSIGNMENT_DELAY 32'd3;
	m <= `BSV_ASSIGNMENT_DELAY 32'd4;
	n <= `BSV_ASSIGNMENT_DELAY 32'd1;
	x <= `BSV_ASSIGNMENT_DELAY 32'd4;
	y <= `BSV_ASSIGNMENT_DELAY 32'd4;
      end
    else
      begin
        if (cntr$EN) cntr <= `BSV_ASSIGNMENT_DELAY cntr$D_IN;
	if (cycle_cntr$EN)
	  cycle_cntr <= `BSV_ASSIGNMENT_DELAY cycle_cntr$D_IN;
	if (kh$EN) kh <= `BSV_ASSIGNMENT_DELAY kh$D_IN;
	if (kl$EN) kl <= `BSV_ASSIGNMENT_DELAY kl$D_IN;
	if (m$EN) m <= `BSV_ASSIGNMENT_DELAY m$D_IN;
	if (n$EN) n <= `BSV_ASSIGNMENT_DELAY n$D_IN;
	if (x$EN) x <= `BSV_ASSIGNMENT_DELAY x$D_IN;
	if (y$EN) y <= `BSV_ASSIGNMENT_DELAY y$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    cntr = 32'hAAAAAAAA;
    cycle_cntr = 32'hAAAAAAAA;
    kh = 32'hAAAAAAAA;
    kl = 32'hAAAAAAAA;
    m = 32'hAAAAAAAA;
    n = 32'hAAAAAAAA;
    x = 32'hAAAAAAAA;
    y = 32'hAAAAAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (cntr == 32'd1) $display("%d\n", $signed(dut$read_check));
    if (RST_N != `BSV_RESET_VALUE)
      if (cntr == 32'd1)
	$display("h = %d, m = %d, kkh = %d, l = %d, n = %d, kkl = %d\n",
		 $signed(dut$check_h),
		 $signed(dut$check_m),
		 $signed(dut$check_kkh),
		 $signed(dut$check_l),
		 $signed(dut$check_n),
		 $signed(dut$check_kkl));
    if (RST_N != `BSV_RESET_VALUE)
      if (cntr == 32'd2)
	$display("%d %d", $signed(cycle_cntr), dut$state_check);
    if (RST_N != `BSV_RESET_VALUE) if (cntr == 32'd2) $finish(32'd0);
    if (RST_N != `BSV_RESET_VALUE)
      if (cntr == 32'd0)
	$display("\nInputs1: H = %d, L = %d N = %d\n",
		 $signed(x),
		 $signed(y),
		 $signed(n));
  end
  // synopsys translate_on
endmodule  // mkTb

